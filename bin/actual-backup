#!/usr/bin/env bash
# Actual Database Backup Script (macOS/Bash 3.2 compatible, hardened)

set -euo pipefail
IFS=$'\n\t'

# ===================== Defaults =====================
DEFAULT_SOURCE_DIR="$HOME/actual/data/user-files"
DEFAULT_BACKUP_DIR="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Actual_Backups"
DEFAULT_MAX_BACKUPS=10
DEFAULT_USE_COMPRESSION=true
DEFAULT_COMPRESSION_TYPE="xz"

CONFIG_DIR="$HOME/.config/actual-backup"
CONFIG_FILE="$CONFIG_DIR/config"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ===================== Load config =====================
# shellcheck disable=SC1090
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# Env overrides
SOURCE_DIR="${ACTUAL_SOURCE_DIR:-${SOURCE_DIR:-$DEFAULT_SOURCE_DIR}}"
BACKUP_DIR="${ACTUAL_BACKUP_DIR:-${BACKUP_DIR:-$DEFAULT_BACKUP_DIR}}"
MAX_BACKUPS="${ACTUAL_MAX_BACKUPS:-${MAX_BACKUPS:-$DEFAULT_MAX_BACKUPS}}"
USE_COMPRESSION="${ACTUAL_USE_COMPRESSION:-${USE_COMPRESSION:-$DEFAULT_USE_COMPRESSION}}"
COMPRESSION_TYPE="${ACTUAL_COMPRESSION_TYPE:-${COMPRESSION_TYPE:-$DEFAULT_COMPRESSION_TYPE}}"

# ===================== Helpers =====================
normalize_bool() {
  s=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$s" in
    1|y|yes|true|on)  echo "true" ;;
    0|n|no|false|off) echo "false" ;;
    *) echo "$1" ;;
  esac
}

is_number() { echo "$1" | grep -Eq '^[0-9]+$'; }

show_help() {
  cat <<EOF
Usage: actual-backup [OPTIONS]

Backup Actual database files with configurable options.

Options:
  -h, --help              Show this help message
  -c, --config            Show current configuration
  -s, --source DIR        Source directory (default: $DEFAULT_SOURCE_DIR)
  -d, --destination DIR   Backup destination directory
  -m, --max-backups NUM   Maximum number of backups to keep (default: $DEFAULT_MAX_BACKUPS)
      --no-compression    Disable compression
      --compression TYPE  Compression type: xz, gzip, bzip2 (default: xz)

Environment variables:
  ACTUAL_SOURCE_DIR, ACTUAL_BACKUP_DIR, ACTUAL_MAX_BACKUPS,
  ACTUAL_USE_COMPRESSION, ACTUAL_COMPRESSION_TYPE

Configuration file: $CONFIG_FILE
EOF
}

show_config() {
  use_comp_disp=$(normalize_bool "$USE_COMPRESSION")
  ctype_lower=$(printf '%s' "$COMPRESSION_TYPE" | tr '[:upper:]' '[:lower:]')
  echo -e "${BLUE}Current Configuration:${NC}"
  echo "  Source Directory: $SOURCE_DIR"
  echo "  Backup Directory: $BACKUP_DIR"
  echo "  Max Backups: $MAX_BACKUPS"
  echo "  Use Compression: $use_comp_disp"
  echo "  Compression Type: $ctype_lower"
  echo "  Config File: $CONFIG_FILE"
}

# ===================== Parse args =====================
while [ $# -gt 0 ]; do
  case $1 in
    -h|--help)   show_help; exit 0 ;;
    -c|--config) show_config; exit 0 ;;
    -s|--source) SOURCE_DIR="$2"; shift 2 ;;
    -d|--destination) BACKUP_DIR="$2"; shift 2 ;;
    -m|--max-backups) MAX_BACKUPS="$2"; shift 2 ;;
    --no-compression) USE_COMPRESSION=false; shift ;;
    --compression) COMPRESSION_TYPE="$2"; shift 2 ;;
    *) echo "Unknown option: $1"; show_help; exit 1 ;;
  esac
done

# Normalize / validate
USE_COMPRESSION="$(normalize_bool "$USE_COMPRESSION")"
if ! is_number "$MAX_BACKUPS"; then
  echo -e "${RED}❌ Error: --max-backups must be a non-negative integer${NC}"
  exit 1
fi
ctype=$(printf '%s' "$COMPRESSION_TYPE" | tr '[:upper:]' '[:lower:]')
ctype_upper=$(printf '%s' "$ctype" | tr '[:lower:]' '[:upper:]')

echo -e "${YELLOW}🗄️  Starting Actual Database Backup${NC}"
[ "$USE_COMPRESSION" = "true" ] && echo -e "${YELLOW}   Using ${ctype_upper} compression${NC}"

# ===================== Pre-flight checks =====================
if [ ! -d "$SOURCE_DIR" ]; then
  echo -e "${RED}❌ Error: Source directory not found: $SOURCE_DIR${NC}"
  exit 1
fi
if [ ! -r "$SOURCE_DIR" ]; then
  echo -e "${RED}❌ Error: Source directory is not readable: $SOURCE_DIR${NC}"
  exit 1
fi

FILE_COUNT=$(find "$SOURCE_DIR" -type f | wc -l | tr -d ' ')
if [ "$FILE_COUNT" -eq 0 ]; then
  echo -e "${RED}❌ Error: No files found in source directory: $SOURCE_DIR${NC}"
  exit 1
fi

mkdir -p "$BACKUP_DIR"
if [ ! -w "$BACKUP_DIR" ]; then
  echo -e "${RED}❌ Error: Backup directory is not writable: $BACKUP_DIR${NC}"
  exit 1
fi

ORIG_SIZE_K=$(du -sk "$SOURCE_DIR" 2>/dev/null | cut -f1 || echo 0)
ORIG_SIZE_MB=$(( ORIG_SIZE_K / 1024 ))
echo -e "${YELLOW}📋 Processing database files...${NC}"
echo -e "${YELLOW}   Files: $FILE_COUNT${NC}"
echo -e "${YELLOW}   Original size: ${ORIG_SIZE_MB} MB${NC}"

TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
EXT="tar"
case "$ctype" in
  xz)    EXT="tar.xz" ;;
  gzip)  EXT="tar.gz" ;;
  bzip2) EXT="tar.bz2" ;;
  *)     ctype="xz"; EXT="tar.xz" ;;
esac
FINAL_FILE="$BACKUP_DIR/actual_backup_${TIMESTAMP}.${EXT}"
TMP_FILE="${FINAL_FILE}.part"

# Compressor availability
if [ "$USE_COMPRESSION" = "true" ]; then
  case "$ctype" in
    xz)    command -v xz >/dev/null 2>&1 || { echo -e "${RED}❌ xz not found${NC}"; exit 1; } ;;
    gzip)  command -v gzip >/dev/null 2>&1 || { echo -e "${RED}❌ gzip not found${NC}"; exit 1; } ;;
    bzip2) command -v bzip2 >/dev/null 2>&1 || { echo -e "${RED}❌ bzip2 not found${NC}"; exit 1; } ;;
  esac
fi

# Clean temp file on exit
cleanup() { rm -f -- "$TMP_FILE" 2>/dev/null || true; }
trap cleanup EXIT

# ===================== Create archive (include dotfiles) =====================
echo -e "${YELLOW}📦 Creating archive...${NC}"
if [ "$USE_COMPRESSION" = "true" ]; then
  case "$ctype" in
    xz)
      # Portable: tar piped to xz; try multithread if supported
      if xz -T0 --version >/dev/null 2>&1; then
        tar -C "$SOURCE_DIR" -c . | xz -T0 -c > "$TMP_FILE"
      else
        tar -C "$SOURCE_DIR" -c . | xz -c > "$TMP_FILE"
      fi
      ;;
    gzip)
      tar -C "$SOURCE_DIR" -czf "$TMP_FILE" .
      ;;
    bzip2)
      tar -C "$SOURCE_DIR" -cjf "$TMP_FILE" .
      ;;
  esac
else
  tar -C "$SOURCE_DIR" -cf "$TMP_FILE" .
fi

# ===================== Verify archive =====================
echo -e "${YELLOW}🔍 Verifying archive...${NC}"
if ! tar -tf "$TMP_FILE" >/dev/null 2>&1; then
  echo -e "${RED}❌ Archive verification failed${NC}"
  exit 1
fi

# Compression stats
if command -v stat >/dev/null 2>&1; then
  COMP_SIZE=$(stat -f%z "$TMP_FILE" 2>/dev/null || stat -c%s "$TMP_FILE" 2>/dev/null || echo "0")
  if [ "${COMP_SIZE:-0}" -gt 0 ] && [ "${ORIG_SIZE_K:-0}" -gt 0 ]; then
    COMP_MB=$(( COMP_SIZE / 1024 / 1024 ))
    RATIO=$(( COMP_SIZE * 100 / (ORIG_SIZE_K * 1024) ))
    SAVINGS=$(( 100 - RATIO ))
    echo -e "${GREEN}   Compressed size: ${COMP_MB} MB (${SAVINGS}% savings)${NC}"
  fi
fi

# Atomic move into place
mv -f "$TMP_FILE" "$FINAL_FILE"
trap - EXIT

echo -e "${GREEN}✅ Backup completed successfully!${NC}"
echo -e "${GREEN}📊 Backup Details:${NC}"
echo -e "   📂 Location: $FINAL_FILE"
echo -e "   📄 Files: $FILE_COUNT"
echo -e "   🕒 Timestamp: $TIMESTAMP"

# ===================== Rotation (portable) =====================
if [ "$MAX_BACKUPS" -gt 0 ]; then
  echo -e "${YELLOW}🧹 Cleaning up old backups (keeping last $MAX_BACKUPS)...${NC}"
  # BSD/macOS-friendly: use ls -t and awk to skip the newest N
  # Handles no matches gracefully due to '|| true'
  ls -1t "$BACKUP_DIR"/actual_backup_*.tar* 2>/dev/null | awk "NR>$MAX_BACKUPS" | \
  while IFS= read -r old; do
    [ -f "$old" ] && { echo -e "${YELLOW}🗑️  Removing: $(basename "$old")${NC}"; rm -f -- "$old"; }
  done || true
fi

# Optional: checksum (uncomment to enable)
# if command -v shasum >/dev/null 2>&1; then
#   shasum -a 256 "$FINAL_FILE" > "$FINAL_FILE.sha256"
# elif command -v sha256sum >/dev/null 2>&1; then
#   sha256sum "$FINAL_FILE" > "$FINAL_FILE.sha256"
# fi

echo -e "${GREEN}🎉 Backup process completed!${NC}"