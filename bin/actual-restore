#!/usr/bin/env bash

# Actual Database Restore Script
# Restores Actual database backup from cloud storage
# 
# Configuration via environment variables or ~/.config/actual-backup/config

set -euo pipefail
IFS=$'\n\t'

# Default configuration
DEFAULT_TARGET_DIR="$HOME/actual/data/user-files"
DEFAULT_BACKUP_DIR="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Actual_Backups"
DEFAULT_CREATE_SAFETY_BACKUP=true
DEFAULT_REQUIRE_CONFIRMATION=true

# Configuration file paths
CONFIG_DIR="$HOME/.config/actual-backup"
CONFIG_FILE="$CONFIG_DIR/config"

# Load configuration from file if it exists
# shellcheck disable=SC1090
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# Environment variables override config file
TARGET_DIR="${ACTUAL_TARGET_DIR:-${TARGET_DIR:-$DEFAULT_TARGET_DIR}}"
BACKUP_DIR="${ACTUAL_BACKUP_DIR:-${BACKUP_DIR:-$DEFAULT_BACKUP_DIR}}"
CREATE_SAFETY_BACKUP="${ACTUAL_CREATE_SAFETY_BACKUP:-${CREATE_SAFETY_BACKUP:-$DEFAULT_CREATE_SAFETY_BACKUP}}"
REQUIRE_CONFIRMATION="${ACTUAL_REQUIRE_CONFIRMATION:-${REQUIRE_CONFIRMATION:-$DEFAULT_REQUIRE_CONFIRMATION}}"

# Generate temp directory (created later)
TEMP_DIR=""

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

normalize_bool() {
  s=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$s" in
    1|y|yes|true|on)  echo "true" ;;
    0|n|no|false|off) echo "false" ;;
    *) echo "$1" ;;
  esac
}

# Help function
show_help() {
    echo "Usage: actual-restore [OPTIONS] [BACKUP_FILE]"
    echo ""
    echo "Restore Actual database files from backup."
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  -c, --config            Show current configuration"
    echo "  -t, --target DIR        Target directory (default: $DEFAULT_TARGET_DIR)"
    echo "  -b, --backup-dir DIR    Backup directory to search (default: auto-detect)"
    echo "  -l, --list              List available backups"
    echo "  -f, --force             Skip confirmation prompts"
    echo "  --no-safety-backup      Skip creating safety backup of existing files"
    echo ""
    echo "Environment variables:"
    echo "  ACTUAL_TARGET_DIR           Target directory for restored files"
    echo "  ACTUAL_BACKUP_DIR           Directory containing backup files"
    echo "  ACTUAL_CREATE_SAFETY_BACKUP Create safety backup (true/false)"
    echo "  ACTUAL_REQUIRE_CONFIRMATION Require user confirmation (true/false)"
    echo ""
    echo "Configuration file: $CONFIG_FILE"
    echo ""
    echo "Examples:"
    echo "  actual-restore                                   # Restore latest backup"
    echo "  actual-restore actual_backup_20240824_154500.tar.xz  # Restore specific backup"
    echo "  actual-restore -l                               # List available backups"
    echo "  actual-restore -f                               # Force restore without confirmation"
    echo "  actual-restore -t ~/myapp/data                  # Custom target directory"
}

show_config() {
    echo -e "${BLUE}Current Configuration:${NC}"
    echo "  Target Directory: $TARGET_DIR"
    echo "  Backup Directory: $BACKUP_DIR"
    echo "  Create Safety Backup: $CREATE_SAFETY_BACKUP"
    echo "  Require Confirmation: $REQUIRE_CONFIRMATION"
    echo "  Config File: $CONFIG_FILE"
}

list_backups() {
    echo -e "${BLUE}üìã Available Backups in $BACKUP_DIR:${NC}"
    echo ""
    
    if [ ! -d "$BACKUP_DIR" ]; then
        echo -e "${RED}‚ùå Backup directory not found: $BACKUP_DIR${NC}"
        exit 1
    fi
    
    cd "$BACKUP_DIR"
    BACKUPS=$(ls -1t actual_backup_*.tar* 2>/dev/null || true)
    
    if [ -z "$BACKUPS" ]; then
        echo -e "${YELLOW}   No backup files found${NC}"
        exit 0
    fi
    
    echo "$BACKUPS" | while IFS= read -r backup; do
        if [ -f "$backup" ]; then
            SIZE=$(ls -lh "$backup" | awk '{print $5}')
            DATE=$(echo "$backup" | sed 's/actual_backup_\\([0-9]*\\)_\\([0-9]*\\)\\.tar\\..*/\\1 \\2/' | awk '{print substr($1,1,4)"-"substr($1,5,2)"-"substr($1,7,2)" "substr($2,1,2)":"substr($2,3,2)":"substr($2,5,2)}')
            echo -e "   üì¶ ${GREEN}$backup${NC} (${SIZE}) - ${DATE}"
        fi
    done
}

# Function to cleanup temp directory
cleanup() {
    if [ -d "$TEMP_DIR" ]; then
        echo -e "${YELLOW}üßπ Cleaning up temporary files...${NC}"
        rm -rf "$TEMP_DIR"
    fi
}

# Set trap to cleanup on exit
trap cleanup EXIT

# Variables for script operation
SPECIFIC_BACKUP=""
FORCE_MODE=false
LIST_MODE=false

# Parse command line arguments
while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -c|--config)
            show_config
            exit 0
            ;;
        -l|--list)
            LIST_MODE=true
            shift
            ;;
        -t|--target)
            TARGET_DIR="$2"
            shift 2
            ;;
        -b|--backup-dir)
            BACKUP_DIR="$2"
            shift 2
            ;;
        -f|--force)
            FORCE_MODE=true
            REQUIRE_CONFIRMATION=false
            shift
            ;;
        --no-safety-backup)
            CREATE_SAFETY_BACKUP=false
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            # Assume it's a backup file name
            SPECIFIC_BACKUP="$1"
            shift
            ;;
    esac
done

# Handle list mode
if [ "$LIST_MODE" = true ]; then
    list_backups
    exit 0
fi

echo -e "${BLUE}üîÑ Actual Database Restore Script${NC}"
echo -e "${BLUE}=================================${NC}"

# Normalize booleans
CREATE_SAFETY_BACKUP="$(normalize_bool "$CREATE_SAFETY_BACKUP")"
REQUIRE_CONFIRMATION="$(normalize_bool "$REQUIRE_CONFIRMATION")"

# Check if backup directory exists and is readable
if [ ! -d "$BACKUP_DIR" ]; then
    echo -e "${RED}‚ùå Error: Backup directory not found at $BACKUP_DIR${NC}"
    echo -e "${RED}   Use -b to specify a different backup directory${NC}"
    exit 1
fi
if [ ! -r "$BACKUP_DIR" ]; then
    echo -e "${RED}‚ùå Error: Backup directory is not readable: $BACKUP_DIR${NC}"
    exit 1
fi

# Find backup to restore
if [ -n "$SPECIFIC_BACKUP" ]; then
    # Check if it's a full path or just filename
    if [ -f "$SPECIFIC_BACKUP" ]; then
        BACKUP_PATH="$SPECIFIC_BACKUP"
        BACKUP_FILE=$(basename "$SPECIFIC_BACKUP")
    elif [ -f "$BACKUP_DIR/$SPECIFIC_BACKUP" ]; then
        BACKUP_PATH="$BACKUP_DIR/$SPECIFIC_BACKUP"
        BACKUP_FILE="$SPECIFIC_BACKUP"
    else
        echo -e "${RED}‚ùå Error: Backup file not found: $SPECIFIC_BACKUP${NC}"
        exit 1
    fi
else
    # Find the latest backup
    echo -e "${YELLOW}üîç Looking for latest backup...${NC}"
    cd "$BACKUP_DIR"
    BACKUP_FILE=$(ls -1t actual_backup_*.tar* 2>/dev/null | head -n 1 || true)
    
    if [ -z "$BACKUP_FILE" ]; then
        echo -e "${RED}‚ùå Error: No backup files found in $BACKUP_DIR${NC}"
        echo -e "${RED}   Use actual-restore -l to see available backups${NC}"
        exit 1
    fi
    
    BACKUP_PATH="$BACKUP_DIR/$BACKUP_FILE"
fi

echo -e "${GREEN}üì¶ Found backup: $BACKUP_FILE${NC}"

# Get backup info
# Prefer stat when available
if command -v stat >/dev/null 2>&1; then
    BACKUP_SIZE=$(stat -f%z "$BACKUP_PATH" 2>/dev/null || stat -c%s "$BACKUP_PATH" 2>/dev/null || echo "")
    if [ -n "${BACKUP_SIZE}" ]; then
        # humanize MB when possible
        BACKUP_SIZE="$(( BACKUP_SIZE / 1024 / 1024 )) MB"
    else
        BACKUP_SIZE=$(ls -lh "$BACKUP_PATH" | awk '{print $5}')
    fi
else
    BACKUP_SIZE=$(ls -lh "$BACKUP_PATH" | awk '{print $5}')
fi
BACKUP_DATE=$(echo "$BACKUP_FILE" | sed 's/actual_backup_\\([0-9]*\\)_\\([0-9]*\\)\\.tar\\..*/\\1 \\2/' | awk '{print substr($1,1,4)"-"substr($1,5,2)"-"substr($1,7,2)" "substr($2,1,2)":"substr($2,3,2)":"substr($2,5,2)}')

echo -e "${BLUE}üìä Backup Information:${NC}"
    echo -e "   üìÇ File: $BACKUP_FILE"
    echo -e "   üíæ Size: $BACKUP_SIZE"
    echo -e "   üìÖ Date: $BACKUP_DATE"
    echo ""

# Safety check - show current files
if [ -d "$TARGET_DIR" ] && [ "$(find "$TARGET_DIR" -type f 2>/dev/null | wc -l)" -gt 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Current files in target directory will be replaced:${NC}"
    find "$TARGET_DIR" -type f -exec ls -lh -- {} + 2>/dev/null | awk '{print "   üìÑ "$9" ("$5")"}' || true
    echo ""
    
    if [ "$REQUIRE_CONFIRMATION" = "true" ]; then
        read -p "$(echo -e "${YELLOW}‚ùì Do you want to continue? This will REPLACE current files! (y/N): ${NC}")" -n 1 -r
        echo ""
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${BLUE}üö´ Restore cancelled by user.${NC}"
            exit 0
        fi
    fi
fi

# Create temporary directory
echo -e "${YELLOW}üìÅ Creating temporary directory...${NC}"
TEMP_DIR=$(mktemp -d -t actual_restore.XXXXXX)

# Verify archive and prepare extraction
echo -e "${YELLOW}üìã Verifying and extracting backup...${NC}"

# Determine extraction method based on file extension
case "$BACKUP_FILE" in
    *.tar.xz)
        command -v xz >/dev/null 2>&1 || { echo -e "${RED}‚ùå xz not found${NC}"; exit 1; }
        if ! xz -t "$BACKUP_PATH" >/dev/null 2>&1; then
            echo -e "${RED}‚ùå Error: Corrupted or unreadable xz archive${NC}"; exit 1
        fi
        xz -dc -- "$BACKUP_PATH" | tar -x -C "$TEMP_DIR"
        ;;
    *.tar.gz)
        command -v gzip >/dev/null 2>&1 || { echo -e "${RED}‚ùå gzip not found${NC}"; exit 1; }
        if ! gzip -t "$BACKUP_PATH" >/dev/null 2>&1; then
            echo -e "${RED}‚ùå Error: Corrupted or unreadable gzip archive${NC}"; exit 1
        fi
        gzip -dc -- "$BACKUP_PATH" | tar -x -C "$TEMP_DIR"
        ;;
    *.tar.bz2)
        command -v bzip2 >/dev/null 2>&1 || { echo -e "${RED}‚ùå bzip2 not found${NC}"; exit 1; }
        # bzip2 has no test mode universally; rely on tar failure
        bzip2 -dc -- "$BACKUP_PATH" | tar -x -C "$TEMP_DIR"
        ;;
    *.tar)
        tar -x -f "$BACKUP_PATH" -C "$TEMP_DIR"
        ;;
    *)
        echo -e "${RED}‚ùå Error: Unknown backup file format: $BACKUP_FILE${NC}"
        exit 1
        ;;
esac

# Count extracted files
EXTRACTED_FILES=$(find . -type f | wc -l | tr -d ' ')
echo -e "${GREEN}‚úÖ Extracted $EXTRACTED_FILES files${NC}"

# Backup existing files (if any)
if [ "$CREATE_SAFETY_BACKUP" = "true" ] && [ -d "$TARGET_DIR" ] && [ "$(find "$TARGET_DIR" -type f 2>/dev/null | wc -l)" -gt 0 ]; then
    BACKUP_TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    SAFETY_BACKUP_DIR="${TARGET_DIR}.backup_$BACKUP_TIMESTAMP"
    
    echo -e "${YELLOW}üíæ Creating safety backup of current files...${NC}"
    if command -v rsync >/dev/null 2>&1; then
        rsync -a -- "$TARGET_DIR/" "$SAFETY_BACKUP_DIR/"
    else
        cp -a "$TARGET_DIR" "$SAFETY_BACKUP_DIR"
    fi
    echo -e "${GREEN}   Safety backup created: $SAFETY_BACKUP_DIR${NC}"
fi

# Create target directory
mkdir -p "$TARGET_DIR"

# Clear target directory (including dotfiles)
echo -e "${YELLOW}üóëÔ∏è  Clearing target directory...${NC}"
find "$TARGET_DIR" -mindepth 1 -maxdepth 1 -exec rm -rf -- {} +

# Copy restored files (preserve attributes, include dotfiles)
echo -e "${YELLOW}üìã Copying restored files...${NC}"
if command -v rsync >/dev/null 2>&1; then
    rsync -a -- "$TEMP_DIR/" "$TARGET_DIR/"
else
    cp -a "$TEMP_DIR"/. "$TARGET_DIR"/
fi

# Verify restoration
RESTORED_FILES=$(find "$TARGET_DIR" -type f | wc -l | tr -d ' ')
TOTAL_SIZE=$(du -sh "$TARGET_DIR" | cut -f1)

echo ""
echo -e "${GREEN}üéâ Restore completed successfully!${NC}"
echo -e "${GREEN}üìä Restore Details:${NC}"
echo -e "   üìÇ Location: $TARGET_DIR"
echo -e "   üìÑ Files Restored: $RESTORED_FILES"
echo -e "   üíæ Total Size: $TOTAL_SIZE"
echo -e "   üì¶ From Backup: $BACKUP_FILE"
echo -e "   üìÖ Backup Date: $BACKUP_DATE"

# Show restored files (count only for portability)
echo ""
echo -e "${BLUE}üìã Restored Files (count): ${RESTORED_FILES}${NC}"

echo ""
echo -e "${GREEN}‚úÖ Database restoration complete!${NC}"
echo -e "${BLUE}üí° Your Actual server can now be restarted to use the restored database.${NC}"
